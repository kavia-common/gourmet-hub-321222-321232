# Zwiggy Database (PostgreSQL) â€” Schema + Minimal Seed Data

This container uses the existing `startup.sh` approach to start PostgreSQL and writes the connection string to `db_connection.txt`.

## Connection / Ports (important)

- PostgreSQL server runs on **port 5000** (as configured in `startup.sh` and `db_connection.txt`)
- The **DB visualizer** is a separate Node server that typically runs on **port 5001** (container runtime metadata shows `zwiggy_database` URL at `:5001`)

So:
- Use **5000** to connect with `psql`
- Use **5001** to open the database visualizer UI in the browser

### Connect with psql (authoritative)
Always use:

```bash
cat db_connection.txt
# psql postgresql://appuser:dbuser123@localhost:5000/myapp
```

If you need a manual command:

```bash
psql -h localhost -p 5000 -U appuser -d myapp
```

### DB visualizer
The DB visualizer reads `db_visualizer/postgres.env`, which is generated by `startup.sh` to point at port 5000.

From `zwiggy_database/db_visualizer`:

```bash
source postgres.env
npm install
npm start
```

Then open the visualizer (commonly exposed as port 5001 by the runtime).

---

## Schema overview

Tables implemented:

### `users`
- Stores authentication and user profile info.
- Roles: `customer` (default), `owner` (restaurant owner), etc.

Key columns:
- `id uuid PK`
- `email text UNIQUE`
- `password_hash text`
- `role text`
- timestamps

### `restaurants`
- Optional `owner_user_id` references `users(id)`.

### `menu_items`
- Belongs to a restaurant (`restaurant_id`).
- Uses `price_cents integer` for currency safety.

### `carts`
- One cart per user enforced by `UNIQUE(user_id)`.
- Tracks which restaurant the cart is currently associated with (optional).

### `cart_items`
- Items in a cart; stores a snapshot `unit_price_cents` to avoid price-change surprises.
- Enforces `UNIQUE(cart_id, menu_item_id)`.

### `orders`
- A placed order, current `status`, monetary totals in cents.

### `order_items`
- Snapshot of purchased items at checkout time (`item_name`, `unit_price_cents`, etc.).

### `order_status_history`
- Append-only status transitions for an order (placed -> accepted -> preparing -> out_for_delivery -> delivered, etc).

---

## How the schema was created

The schema is created directly in the running PostgreSQL instance using one-statement-at-a-time `psql -c` calls (no `.sql` files), per container rules.

It uses `pgcrypto` for UUID generation via `gen_random_uuid()`:

```sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;
```

---

## Minimal seed data

Seeded rows (stable UUIDs for easy referencing across backend/frontend/dev):

- `users`
  - `customer1@zwiggy.local` (id `00000000-0000-0000-0000-000000000001`)
  - `owner1@zwiggy.local` (id `00000000-0000-0000-0000-000000000002`)
- `restaurants`
  - `Zwiggy Bites` (id `00000000-0000-0000-0000-000000010001`)
- `menu_items`
  - `Paneer Tikka Wrap` (id `00000000-0000-0000-0000-000000020001`)
  - `Masala Fries` (id `00000000-0000-0000-0000-000000020002`)
- `carts` + `cart_items`
  - one active cart for the demo customer with one item
- `orders` + `order_items` + `order_status_history`
  - one demo order + one item + initial status history row

Seed inserts were done using `ON CONFLICT DO NOTHING` to make the operation re-runnable.

---

## Inspect via the visualizer

Once the visualizer connects, you should see the tables in the `public` schema:

- users
- restaurants
- menu_items
- carts
- cart_items
- orders
- order_items
- order_status_history
